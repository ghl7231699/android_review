### 精度为什么会丢失，计算机能存那么多数字，一个0.3+0.6怎么就丢精度了呢？

System.out.println(0.3f+0.6f);
System.out.println(0.3+0.6);
System.out.println(0.9);

上述代码的输出结果为

```
0.90000004
0.8999999999999999
0.9
```
通过上面的结果来看，**为何float和double的计算输出结果差异这么大呢？**

以下的回答都是基于JDK1.8而言。

先抛开这个问题，来看下十进制小数是如何转成二进制的。

采用"乘2取整，顺序排列"法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。

然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。

0.3×2=0.6 0

0.6×2=1.2 1

0.2×2=0.4 0

0.4×2=0.8 0

0.8×2=1.6 1

0.6×2=1.2 1

0.2×2=0.4 0

0.4×2=0.8 0

0.8×2=1.6 1

所以，转换为二进制是：0.010011001…（其中1001是循环节）

二进制换为十进制

0.010011001=2^（-2）+2^（-5）+2^（-6）+2^（-9）

≈1/4+1/32+1/64+1/512

≈0.25+0.03125+0.015625+0.001953125

≈0.298828125

所以，转换为十进制是：0.298828125。

我们都知道浮点数在计算机中的存储方式其实是以补码的形式存在的。

在计算机中，数字都是用补码来表示与存储的。

正数的补码是其二进制表示的，负数的补码是其正数的二进制取反+1。

为什么0.3+0.6会导致精度丢失了呢？

0.3转换为二进制为0.0100110011001100，结果是保留16位的，这就会导致精度的丢失；0.6转化为0.1001100110011001，结果是保留16位的，也导致了精度的丢失；相加起来就是0.1110011001100101，再转化为十进制为0.8999786376953125，与我们上面输出的结果有所差异，是因为保留的精度不同导致的。

再来看float和double的计算结果为什么差异这么大：

主要是因为float和double所占的字节不同，计算精度也不同。最关键的是保留有效数字的规则不同，十进制中我们是**四舍五入**，而二进制中是**0舍1入**。

所以在上面0.3f转化为二进制保留8位小数是0.01001101，0.6f转化为二进制保留8位小数是0.10011010。加起来是0.11100111，转换为十进制就是0.90234375。所以float和double的计算结果输出结果差异挺大是因为**保留有效数字时的0舍1入**造成的。

**补充一点：在android官方文档的性能提示的部分说了一个“避免使用浮点数”，在 Android 设备上，浮点数要比整数慢约2倍。**
