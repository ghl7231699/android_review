# 20191231
### 简述一下 Android中UI的刷新机制？

我们主要通过应用层和系统层两个方面来说明。

#### 应用层
**界面刷新的本质流程**

1. 通过ViewRootImpl的ScheduleTraversals()进行界面的三大流程。
2. 调用到scheduleTraversals()时不会立即执行，而是将操作保存到待执行队列中，并给底层的刷新信号注册监听。
3. 当VSYNC信号到来时，会从待执行队列中取出对应的scheduleTraversals（）操作，并将其加入到主线程的消息队列中。
4. 主线程从消息队列中取出并执行三大流程：onMeasure()->onLayout()->onDraw()

**同步屏障的作用**

1. 同步屏障用于阻塞住所有的同步消息（底层VSYNC的回调onVsync方法提交的消息是异步消息）。
2. 用于保证界面刷新功能的performTraversals()的优先执行。

**同步屏障的原理**

1. 主线程Looper会一直循环调用MessageQueue的next()方法并取出队列头部的Message执行，遇到同步屏障（一种特殊消息）后会去寻找异步消息执行。如果没有找到异步消息就会一直阻塞下去，除非将同步屏障取出，否则永远不会执行同步消息。
2. 界面刷新操作是异步消息，具有最高优先级
3. 我们发送的消息是同步消息，再多耗时操作也不会影响UI的刷新操作。

#### 系统层

首先屏幕是大约16.6ms刷新一次（固定的），当界面需要刷新时，CPU开始计算，将计算结果赋予GPU的buffer缓存起来，等待刷新时间的到来，然后根据buffer的数据刷新界面。

如果当前界面没有变化，CPU不用计算，也不会给GPU的buffer赋值，这个buffer就没有变化，等到刷新时间到来，根据buffer刷新屏幕。

界面改不改变都会刷新界面，区别只是在于CPU是否计算。

UI刷新卡顿，基本都在于卡在CPU计算这一环节，对于根据GPU 的buffer刷新这一环节，在系统里有很高的优先级，同步屏障就是保护这一优先级的一个手段。