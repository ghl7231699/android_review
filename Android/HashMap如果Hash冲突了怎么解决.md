# 20191219
### HashMap如果Hash冲突了怎么解决

常用的两种方式：**链表法**和**开放寻址法**

#### 链表法

在哈希表中，每一个桶（bucket）或者槽（slot）都会对应一条链表，所有哈希值相同的元素放到相同槽位对应的链表中。

在插入的时候，我们可以通过散列函数计算出对应的散列槽位，将元素插入到对应的链表即可，时间复杂度为O（1）；在查找或删除元素时，我们同样通过散列函数计算出对应的散列槽位，然后再通过遍历链表进行查找或删除，时间复杂度为O（k），k为链表长度。

#### 开放寻址法

核心思想：如果出现散列冲突，我们就重新探测一个空闲位置，再将元素插入。

一种比较简单的探测方法：线性探测法（Linear Probing）

但我们往散列表中插入元素时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，那么我们就从当前位置开始，依次往后遍历，直到找到空余的位置插入为止（插入第一个空余的位置，方便查找）

在查找元素时，先将要查找元素键值通过散列函数变成散列值，然后与下标为散列值的元素比较，若相等，则说明这是我们要找的元素；若不相等，则顺序往后遍历查找，如果遍历到数组中的空余位置还是没有找到，说明要查找的元素不在散列表中。

删除元素时，删除操作不能简单地把元素设置为空，而是要特殊标记为deleted，因为如果简单设置为空，在查找元素的过程中遇到这个被删除元素的位置就会停下，而不是继续往后遍历，会使查找算法失效；但是如果特色标记为deleted，当线性探测查找时，遇到标记为deleted的位置就会往下探测。

线性探测法的缺点：当插入的数据越来越多时，散列冲突发生的可能性会越来越大，空余位置会越来越少，线性探测的时间会越来越长，最坏时间复杂度为O（n）。

另外的两种探测方法是二次探测法（Quadratic probing）和双重散列法（Double hashing）。
