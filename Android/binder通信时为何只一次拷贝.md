### 20191106
#### binder在通信时，为什么只需要一次拷贝？
要回答上面这个问题需要从Binder的跨进程通信原理说起。
我们知道跨进程通信是需要内核空间做支持的。传统的IPC机制如管道、Socket都是内核的一部分，因此通过内核支持来实现进程间通信是没有问题的。但是Binder并不是Linux系统内核的一部分，那怎么办呢？这就需要依赖Linux的动态内核可加载模块（Loadable Kernel Module,LKM）机制。模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。

在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。
> 在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 Binder 驱动（Binder Dirver）。

那么Android系统中用户进程之间是如何通过Binder驱动来实现通信的呢？ 
 
这就不得不提到Linux的另一个概念：**内存映射**  。  

Binder IPC 机制中涉及到的内存映射通过mmap（）来实现，mmap（）是操作系统中一种内存映射的方法。简单的讲内存映射就是将用户空间的一块内存映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这块区域的修改也能直接反应到用户空间。  

内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。  

Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。  

比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘-->内核空间-->用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。

一次完整的 Binder IPC 通信过程通常是这样：  
  1. 首先Binder驱动在内核空间创建一个数据接收缓存区；  
  2. 接着在内核空间开辟一块内存缓存区，建立**内存缓存区**和**内核中数据接收缓存区**之间的内存映射关系，以及**内核中数据接收缓存区**和**接收进程用户空间地址**的映射关系；  
  3. 发送方进程通过系统调用copy_from_user()将数据copy到内核的**内核缓存区**中，由于**内核缓存区**和**接收进程的用户空间**存在内存映射，因此也就相当于把数据发送到了**接收进程的用户空间**，这样便完成了一次进程间的通信。  

如下图：  
![](https://user-gold-cdn.xitu.io/2018/4/10/162b00a9557158d0?imageView2/0/w/1280/h/960/ignore-error/1)




