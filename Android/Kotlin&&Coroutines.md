### 请谈谈Kotlin中的Coroutines，它与线程有什么区别？有哪些优点？

Coroutines就是大名鼎鼎的协程了。

在Java中，在程序运行过程中某些操作（比如网络I/0、文件I/0、CPU或GUP计算密集型工作等等）可能会耗费大量的时间，在单线程的环境下可能会造成线程的阻塞，在它们完成之前没办法做其他事情。

面对这种情况，传统方法的话，我们会使用多线程来解决这个问题，将这些耗时操作放在新的线程中去执行。

在Kotlin中，我们可以使用协程来解决这个问题。

我们来看看官网是如何来定义的：

本质上，协程是轻量级的线程。它们在某些CoroutineScope的上下文中与启动的协程生成器一起启动。在这里，我们正在GlobalScope中启动一个新的协程，这意味着新协程的寿命仅受整个应用程序寿命的限制。

### 轻量级
运行如下代码：

```
runBlocking {
    repeat(100_000) { // launch a lot of coroutines
        launch {
            delay(1000L)
            print(".")
        }
    }
}
```

上面的代码启动了10w个协程，一秒钟后，每个协程打印一个点。如果你要是启动10w个线程呢，会发生什么？（你的代码很可能会产生某种内存不足的错误）

如何理解轻量级呢？这个就要和线程对比理解了，我们常见的大多数线程，以操作系统方面来说线程是映射到内核的线程的，也就是说线程中代码的逻辑在线程抢到CPU资源的时间时才可以执行，否则就是歇着，那么Coroutines说是一个轻量级的线程的意思是，Coroutines并不会映射程内核的线程或者其他重资源，他的调度在用户态就可以搞定，任务之间的调度并非是抢占式的，而是协作式的，Coroutines可以主动挂起和恢复执行，所以说Coroutines是轻量级的线程。

### 全局协程就像守护线程

以下的代码在GlobalScope中启动一个长时间运行的协程，该协程每秒打印两次“我在睡觉”，然后延迟一段时间后从主函数返回：

```
fun main() = runBlocking {
    GlobalScope.launch {
        repeat(1000) { i ->
            println("I'm sleeping $i ...")
            delay(500L)
        }
    }
    delay(1300L) // just quit after delay
}
```

可以看到在显示3行后终止：

```
I'm sleeping 0 ...
I'm sleeping 1 ...
I'm sleeping 2 ...
```

在GlobalScope中启动的主动协程并不能保持该过程的生命。它们就像守护程序线程。


### 协程和线程的区别与关系：

**线程和协程的目的本质上存在差异:**

线程的目的是提高CPU资源使用率, 使多个任务得以并行的运行, 所以线程是为了服务于机器的.
协程的目的是为了让多个任务之间更好的协作, 主要体现在代码逻辑上, 所以协程是为了服务于人的, 写代码的人. (也有可能结果会能提升资源的利用率, 但并不是原始目的)

**在调度上, 协程跟线程也不同:**

线程的调度是系统完成的, 一般是抢占式的, 根据优先级来分配, 是空分复用.
协程的调度是开发者根据程序逻辑指定好的, 在不同的时期把资源合理的分配给不同的任务, 是时分复用的.

**作用上的不同:**

协程确保了代码逻辑是顺序的, 不管同步操作要是异步操作, 前一个完成, 后一个才会开始.
线程可以被调度到CPU上执行, 这样代码才能真正运行起来.

协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程. 可总结如下:

1. 线程是协程的资源.
2. 协程通过Interceptor来间接使用线程这个资源.
